#!/usr/bin/env bash
# portage.sh — Generate make.conf, select profile, sync repository
source "${LIB_DIR}/protection.sh"

# generate_make_conf — Create /etc/portage/make.conf with layered settings
generate_make_conf() {
    einfo "Generating make.conf..."

    if [[ "${DRY_RUN}" == "1" ]]; then
        einfo "[DRY-RUN] Would generate make.conf"
        _print_make_conf
        return 0
    fi

    local make_conf="${MOUNTPOINT}/etc/portage/make.conf"
    mkdir -p "$(dirname "${make_conf}")"
    _write_make_conf > "${make_conf}"

    einfo "make.conf generated at ${make_conf}"
}

# _print_make_conf — Print make.conf content (for dry-run / debug)
_print_make_conf() {
    _write_make_conf
}

# _write_make_conf — Generate make.conf content
_write_make_conf() {
    local march="${CPU_MARCH:-x86-64}"
    local jobs="${EMERGE_JOBS_DEFAULT}"
    local load="${EMERGE_LOAD_DEFAULT}"

    # Auto-calculate from CPU count
    local cpu_count
    cpu_count=$(get_cpu_count)
    if (( cpu_count > 1 )); then
        jobs="$(( cpu_count + 1 ))"             # slightly over-subscribe make threads
        load="$(( cpu_count + 2 )).0"            # generous load limit for first install
    fi

    # Parallel package builds: 2 for ≤8 threads, scale up for bigger CPUs
    # Too many parallel emerges eat RAM (each C++ build can use 1-2 GB)
    local emerge_jobs=2
    if (( cpu_count >= 16 )); then
        emerge_jobs=4
    elif (( cpu_count >= 12 )); then
        emerge_jobs=3
    fi

    local use_flags
    use_flags=$(get_use_flags "${INIT_SYSTEM:-systemd}" "${GPU_VENDOR:-}")

    cat << MAKECONF
# /etc/portage/make.conf
# Generated by ${INSTALLER_NAME} v${INSTALLER_VERSION}
# $(date -Iseconds)

# --- Compiler flags ---
COMMON_FLAGS="-march=${march} -O2 -pipe"
CFLAGS="\${COMMON_FLAGS}"
CXXFLAGS="\${COMMON_FLAGS}"
FCFLAGS="\${COMMON_FLAGS}"
FFLAGS="\${COMMON_FLAGS}"

# --- CPU flags ---
$(if [[ -n "${CPU_FLAGS:-}" ]]; then
    echo "CPU_FLAGS_X86=\"${CPU_FLAGS}\""
else
    echo "# CPU_FLAGS_X86 will be set after running cpuid2cpuflags in chroot"
    echo "# CPU_FLAGS_X86=\"\""
fi)

# --- Parallelism ---
MAKEOPTS="-j${jobs} -l${load}"
EMERGE_DEFAULT_OPTS="--jobs=${emerge_jobs} --load-average=${load} --with-bdeps=y --complete-graph=y"

# --- USE flags ---
USE="${use_flags}"

# --- Video ---
VIDEO_CARDS="${VIDEO_CARDS:-fbdev}"

# --- Input devices ---
INPUT_DEVICES="libinput"

# --- Accept licenses ---
ACCEPT_LICENSE="*"

# --- Mirrors ---
GENTOO_MIRRORS="${MIRROR_URL:-https://distfiles.gentoo.org}"

# --- GRUB ---
GRUB_PLATFORMS="${GRUB_PLATFORMS}"

# --- Portage features ---
FEATURES="parallel-fetch candy buildpkg"

# --- Language ---
L10N="$(echo "${LOCALE:-en_US.UTF-8}" | cut -d. -f1 | tr '_' '-') en en-US"
LINGUAS="$(echo "${LOCALE:-en_US.UTF-8}" | cut -d_ -f1) en"
MAKECONF
}

# portage_sync — Initial portage tree sync
portage_sync() {
    einfo "Syncing Portage repository..."

    # First sync with emerge-webrsync (faster initial download)
    try "Running emerge-webrsync" emerge-webrsync

    # Then update with emerge --sync
    try "Running emerge --sync" emerge --sync

    einfo "Portage tree synced"
}

# portage_select_profile — Select the appropriate eselect profile
portage_select_profile() {
    einfo "Selecting Portage profile..."

    local target_profile
    case "${INIT_SYSTEM:-systemd}" in
        systemd) target_profile="${PROFILE_SYSTEMD_DESKTOP}" ;;
        openrc)  target_profile="${PROFILE_OPENRC_DESKTOP}" ;;
    esac

    # Find the profile number
    # Note: || true needed on grep pipelines — grep returns 1 on no match,
    # which kills the script under set -euo pipefail + inherit_errexit
    local profile_num
    profile_num=$(eselect profile list | grep -n "${target_profile}" | head -1 | cut -d: -f1) || true

    if [[ -z "${profile_num}" ]]; then
        # Try partial match
        profile_num=$(eselect profile list | grep -n "plasma" | grep "${INIT_SYSTEM:-systemd}" | head -1 | cut -d: -f1) || true
    fi

    if [[ -z "${profile_num}" ]]; then
        ewarn "Could not find exact profile. Available profiles:"
        eselect profile list || true
        ewarn "Please select manually."

        local manual
        manual=$(eselect profile list | grep -n "desktop" | head -20) || true
        die "Profile selection failed. Available desktop profiles:\n${manual}"
    fi

    # eselect uses 1-based indexing from brackets [N]
    local profile_idx
    profile_idx=$(eselect profile list | grep "${target_profile}" | sed 's/.*\[//;s/\].*//' | head -1) || true

    if [[ -n "${profile_idx}" ]]; then
        try "Setting profile to ${target_profile}" \
            eselect profile set "${profile_idx}"
        einfo "Profile set to: ${target_profile}"
    else
        ewarn "Could not auto-select profile, attempting by name"
        try "Setting profile" eselect profile set "${target_profile}"
    fi
}

# portage_install_cpuflags — Install and run cpuid2cpuflags
portage_install_cpuflags() {
    if [[ -n "${CPU_FLAGS:-}" ]]; then
        einfo "CPU_FLAGS already set: ${CPU_FLAGS}"
        return 0
    fi

    try "Installing cpuid2cpuflags" emerge --quiet app-portage/cpuid2cpuflags

    CPU_FLAGS=$(cpuid2cpuflags 2>/dev/null | sed 's/CPU_FLAGS_X86: //') || CPU_FLAGS=""

    if [[ -n "${CPU_FLAGS}" ]]; then
        einfo "Detected CPU_FLAGS_X86: ${CPU_FLAGS}"
        # Update make.conf
        if [[ -f /etc/portage/make.conf ]]; then
            if grep -q "CPU_FLAGS_X86" /etc/portage/make.conf; then
                sed -i "s/CPU_FLAGS_X86=.*/CPU_FLAGS_X86=\"${CPU_FLAGS}\"/" /etc/portage/make.conf
            else
                echo "CPU_FLAGS_X86=\"${CPU_FLAGS}\"" >> /etc/portage/make.conf
            fi
        fi
    fi
}

# setup_guru_repository — Enable the GURU community overlay
setup_guru_repository() {
    if [[ "${ENABLE_GURU:-no}" != "yes" ]]; then
        return 0
    fi

    einfo "Enabling GURU repository..."

    # GURU uses git for sync — ensure git is installed
    if ! command -v git &>/dev/null; then
        try "Installing dev-vcs/git" emerge --quiet dev-vcs/git
    fi

    # Ensure eselect-repository is available
    if ! eselect repository list &>/dev/null; then
        try "Installing eselect-repository" emerge --quiet app-eselect/eselect-repository
    fi

    try "Enabling GURU overlay" eselect repository enable guru
    try "Syncing GURU overlay" emerge --sync guru
}

# install_noctalia_shell — Install Noctalia Shell + Wayland compositor from GURU
install_noctalia_shell() {
    if [[ "${ENABLE_NOCTALIA:-no}" != "yes" ]]; then
        return 0
    fi

    local compositor="${NOCTALIA_COMPOSITOR:-hyprland}"
    einfo "Installing Noctalia Shell with ${compositor}..."

    # Accept ~amd64 keywords for noctalia-shell and its GURU dependencies
    mkdir -p /etc/portage/package.accept_keywords
    {
        echo "gui-apps/noctalia-shell ~amd64"
        echo "gui-apps/quickshell ~amd64"
        echo "media-video/gpu-screen-recorder ~amd64"
    } > /etc/portage/package.accept_keywords/noctalia-shell

    # Install selected Wayland compositor
    _install_noctalia_compositor "${compositor}"

    # Install Noctalia Shell itself (pulls in quickshell automatically)
    try "Installing noctalia-shell" emerge --quiet gui-apps/noctalia-shell

    # Configure compositor to launch Noctalia Shell
    _configure_noctalia_autostart "${compositor}"
}

# _install_noctalia_compositor — Install the selected Wayland compositor
_install_noctalia_compositor() {
    local compositor="$1"

    case "${compositor}" in
        hyprland)
            mkdir -p /etc/portage/package.accept_keywords
            echo "gui-wm/hyprland ~amd64" >> /etc/portage/package.accept_keywords/noctalia-shell
            try "Installing Hyprland" emerge --quiet gui-wm/hyprland
            ;;
        niri)
            mkdir -p /etc/portage/package.accept_keywords
            echo "gui-wm/niri ~amd64" >> /etc/portage/package.accept_keywords/noctalia-shell
            try "Installing Niri" emerge --quiet gui-wm/niri
            ;;
        sway)
            try "Installing Sway" emerge --quiet gui-wm/sway
            ;;
        *)
            ewarn "Unknown compositor: ${compositor}, skipping"
            ;;
    esac
}

# _configure_noctalia_autostart — Configure compositor to start Noctalia Shell
_configure_noctalia_autostart() {
    local compositor="$1"

    # Create config for all users via skel
    local skel="/etc/skel"

    case "${compositor}" in
        hyprland)
            local conf_dir="${skel}/.config/hypr"
            mkdir -p "${conf_dir}"
            if [[ -f "${conf_dir}/hyprland.conf" ]]; then
                echo 'exec-once = qs -c noctalia-shell' >> "${conf_dir}/hyprland.conf"
            else
                cat > "${conf_dir}/hyprland.conf" << 'HYPREOF'
# Noctalia Shell autostart
exec-once = qs -c noctalia-shell
exec-once = dbus-update-activation-environment --systemd --all
HYPREOF
            fi
            ;;
        niri)
            local conf_dir="${skel}/.config/niri"
            mkdir -p "${conf_dir}"
            if [[ -f "${conf_dir}/config.kdl" ]]; then
                echo 'spawn-at-startup "qs" "-c" "noctalia-shell"' >> "${conf_dir}/config.kdl"
            else
                cat > "${conf_dir}/config.kdl" << 'NIRIEOF'
// Noctalia Shell autostart
spawn-at-startup "qs" "-c" "noctalia-shell"
NIRIEOF
            fi
            ;;
        sway)
            local conf_dir="${skel}/.config/sway"
            mkdir -p "${conf_dir}"
            if [[ -f "${conf_dir}/config" ]]; then
                echo 'exec qs -c noctalia-shell' >> "${conf_dir}/config"
            else
                cat > "${conf_dir}/config" << 'SWAYEOF'
# Noctalia Shell autostart
exec qs -c noctalia-shell
SWAYEOF
            fi
            ;;
    esac

    # Also configure for the created user (if already exists)
    if [[ -n "${USERNAME:-}" ]] && id "${USERNAME}" &>/dev/null; then
        local user_home
        user_home=$(eval echo "~${USERNAME}")
        case "${compositor}" in
            hyprland)
                mkdir -p "${user_home}/.config/hypr"
                cp "${skel}/.config/hypr/hyprland.conf" "${user_home}/.config/hypr/" 2>/dev/null || true
                chown -R "${USERNAME}:${USERNAME}" "${user_home}/.config/hypr"
                ;;
            niri)
                mkdir -p "${user_home}/.config/niri"
                cp "${skel}/.config/niri/config.kdl" "${user_home}/.config/niri/" 2>/dev/null || true
                chown -R "${USERNAME}:${USERNAME}" "${user_home}/.config/niri"
                ;;
            sway)
                mkdir -p "${user_home}/.config/sway"
                cp "${skel}/.config/sway/config" "${user_home}/.config/sway/" 2>/dev/null || true
                chown -R "${USERNAME}:${USERNAME}" "${user_home}/.config/sway"
                ;;
        esac
    fi

    einfo "Noctalia Shell configured to autostart with ${compositor}"
}

# install_extra_packages — Install user-selected extra packages
install_extra_packages() {
    # Enable GURU repo if requested (before installing packages)
    setup_guru_repository

    # Install noctalia-shell if requested
    install_noctalia_shell

    if [[ -z "${EXTRA_PACKAGES:-}" ]]; then
        einfo "No extra packages to install"
        return 0
    fi

    einfo "Installing extra packages: ${EXTRA_PACKAGES}"
    local pkg
    for pkg in ${EXTRA_PACKAGES}; do
        try "Installing ${pkg}" emerge --quiet "${pkg}"
    done
}
